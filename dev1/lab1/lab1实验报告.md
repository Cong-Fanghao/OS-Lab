# Lab1实验报告
## 理解内核启动中的程序入口操作

当操作系统内核开始启动时，计算机还没有一个完好的适用于C语言的环境支持，因此它通常从汇编代码开始，设置基本环境，然后再跳转到C代码的主函数。

la sp, bootstacktop是将bootstacktop这个栈顶的地址放到sp栈指针寄存器当中，也即初始化栈指针。其目的在于为内核执行C代码准备栈空间，保证栈指针指向正确位置，来实现函数调用、变量存储和异常处理等功能。

tail kern_init执行跳转操作，将控制权交给kern_init函数，且不保存返回地址。其目的在于让内核从汇编代码过渡到C代码，进入主初始化函数，执行内存管理、设备初始化等操作。

## 使用GDB验证启动流程
### 基础硬件初始化阶段
首先，使用make debug和make gdb指令在qemu上模拟riscv硬件加电。

使用x/10i 0x1000指令，查看0x1000附近的指令，它们是加电后最初执行的指令，如下：

- 0x1000 : auipc  t0, 0x0
- 0x1004 : addi   a1, t0, 32
- 0x1008 : csrr   a0, mhartid
- 0x100c : ld     t0, 24(t0)
- 0x1010 : jr     t0
- 0x1014 : unimp
- 0x1018 : unimp
- 0x101a : unimp
- 0x101c : 0x8000

这段代码的含义是，将PC的高20位与0相加存到t0中，此时t0的值为0x1000；（而后，将t0与十进制的32相加存到a1之中，此时a1的值为0x1020；把mhartid寄存器的值放到a0中去；）第四条指令的含义是把0x1018（t0+24）处加载一个双字到t0，这时的a0变成了0x80000000，PC最终跳转到这个新的t0所指向的地址。

使用si单步执行后，注意到运行指令的地址从0x1010跳到0x80000000，OpenSBI完成了基础硬件的初始化。

值得注意的是，执行过程中出现大量的"??"符号，说明执行的指令地址没有对应的符号名称，这是因为这部分指令属于引导固件的代码，不属于操作系统内核，没有符号信息。

### SBI固件主初始化阶段
接下来，首先仿照上一步查看分析0x80000000附近的代码:

- 0x80000000 : csrr a6,mhartid
- 0x80000004 : bgtz a6,0x80000108

首先检测CPU核心，若核心不是0号核心，就跳转到其他核心的初始化代码或等待循环，只有0号核心才会继续执行下面的主初始化流程，为跳转到0x80200000做好准备。

### 控制权移交阶段
跳过观看冗长的主初始化阶段，使用watch *0x80200000指令，设置观察点，监视内核的加载过程,但是这里单独使用观察点输入continue之后，程序一直处于运行状态，无法进行下一步操作。

这里，改为使用b *0x80200000指令设置断点进行研究，这个地址的指令是la sp, bootstacktop，也就是entry.s要执行的内核的第一条指令，说明抵达了操作系统内核的入口。