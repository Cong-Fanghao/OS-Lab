# Lab5 用户程序 实验报告
**小组成员：丛方昊_2310682、钱展飞_2312479、李泽昊_2312594**

## 任务管理
- 练习0：填写已有实验
本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行 lab5 的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

- 练习1: 加载应用程序并执行（需要编码）
do_execve函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。
请在实验报告中简要说明你的设计实现过程。

请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。
- 练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。
请在实验报告中简要说明你的设计实现过程。
如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。
Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

- 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：
请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-4.1.1）

- 扩展练习 Challenge
实现 Copy on Write （COW）机制
给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。
这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。
由于COW实现比较复杂，容易引入bug，请参考 https://dirtycow.ninja/ 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。
这是一个big challenge.
说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

## 加载应用程序并执行
1.设计实现过程
在 load_icode 函数的第6步中，需要设置当前进程的 trapframe，以确保进程能够正确地从内核态返回用户态并执行用户程序。具体需要设置三个关键字段：

首先，将 tf->gpr.sp 设置为 USTACKTOP，即用户栈的栈顶地址。在此之前，load_icode 已经通过 mm_map 函数为用户栈建立了虚拟地址映射，并分配了物理页面，因此用户程序可以直接使用这个栈空间。

其次，将 tf->epc 设置为 elf->e_entry，这是ELF文件头中指定的程序入口地址。当执行 sret 指令时，CPU会将PC寄存器设置为 sepc 的值，从而跳转到用户程序的入口点开始执行。

最后，设置 tf->status 为 (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。这里清除了SPP位，表示 sret 返回后进入用户态（U-mode）；同时设置了SPIE位，使得返回用户态后中断被启用。
2.具体代码
```
tf->gpr.sp = USTACKTOP;

tf->epc = elf->e_entry;

tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```
3.用户态进程执行第一条指令的完整过程
当一个用户态进程被ucore选择占用CPU执行，到具体执行应用程序第一条指令，需要经历以下过程：

第一阶段：进程的创建
系统启动时，proc_init 函数首先创建了 idleproc（pid=0）作为第一个内核线程，并将其设置为当前进程。随后通过 kernel_thread 函数创建了 initproc（pid=1）。initproc 运行 init_main 函数，该函数又调用 kernel_thread 创建了运行 user_main 的内核线程。

在 do_fork 过程中，系统为新进程分配了 proc_struct 结构体，设置了内核栈，并通过 copy_thread 函数初始化了进程的上下文。特别地，context.ra 被设置为 forkret 函数的地址，这决定了进程第一次被调度时的执行入口。

第二阶段：进程的调度与切换
idleproc 在 cpu_idle 函数中循环检测 need_resched 标志，当发现需要调度时调用 schedule 函数。调度器从就绪队列中选择合适的进程，然后调用 proc_run 进行进程切换。

proc_run 函数首先将 current 指针指向新进程，然后调用 lsatp 切换到新进程的页表，最后调用 switch_to 进行上下文切换。switch_to 是一段汇编代码，它保存当前进程的寄存器到其 context 结构中，并从新进程的 context 中恢复寄存器。由于新进程的 context.ra 被设置为 forkret，因此 switch_to 返回后会跳转到 forkret 执行。

第三阶段：加载用户程序
forkret 函数调用 forkrets，将控制权交给 user_main。user_main 通过 KERNEL_EXECVE 宏调用 kernel_execve 函数，该函数使用 ebreak 指令触发断点异常来执行系统调用。

系统调用处理程序调用 do_execve 函数。do_execve 首先释放当前进程原有的内存空间（如果有的话），然后调用 load_icode 加载新的用户程序。

load_icode 函数完成以下工作：创建新的 mm_struct 结构和页目录表；解析ELF文件头，将代码段和数据段加载到对应的虚拟地址；为BSS段分配空间并清零；建立用户栈的虚拟地址映射并分配物理页面；最后设置 trapframe，包括用户栈指针、程序入口地址和状态寄存器。

第四阶段：返回用户态
系统调用处理完成后，沿着中断处理的返回路径执行。trap 函数返回后，会执行 trapret 汇编代码，该代码从当前进程的 trapframe 中恢复所有通用寄存器的值。

最后执行 sret 指令。该指令完成三件事：将PC设置为 sepc（即 trapframe 中保存的 epc 值，也就是用户程序的入口地址）；根据 sstatus 中的SPP位将特权级切换到用户态；将SIE位设置为SPIE位的值以启用中断。

至此，CPU开始从用户程序的入口地址取指令执行，用户态进程正式开始运行其第一条指令。整个过程涉及进程创建、调度切换、程序加载和特权级切换四个主要阶段，通过精心设置的 trapframe 实现了从内核态到用户态的平滑过渡。

## copy_range 实现与 Copy on Write 机制设计
1.设计实现过程
1.1 功能需求分析
copy_range 函数的作用是在 do_fork 创建子进程时，将父进程用户地址空间中指定范围内的内存内容复制到子进程中。该函数被 dup_mmap 调用，而 dup_mmap 又被 copy_mm 调用，形成完整的内存复制调用链。

1.2 具体实现
在 copy_range 函数中，对于父进程中每一个有效的页面，需要完成四个步骤的操作。

首先，通过调用 page2kva(page) 函数获取父进程源页面的内核虚拟地址。page2kva 函数将 Page 结构体指针转换为对应物理页面的内核虚拟地址，由于内核地址空间映射了所有物理内存，因此可以通过这个地址直接访问源页面的内容。

其次，通过调用 page2kva(npage) 函数获取子进程新分配页面的内核虚拟地址。在此之前，copy_range 函数已经调用 alloc_page 为子进程分配了一个新的物理页面 npage。

然后，调用 memcpy 函数将源页面的全部内容复制到目标页面。复制的大小为 PGSIZE，即一个页面的大小（4KB）。这一步完成了物理内存内容的实际复制。

最后，调用 page_insert 函数在子进程的页目录表中建立虚拟地址到物理页面的映射。该函数会找到或创建对应的页表项，并将其设置为指向新分配的物理页面 npage，同时设置从父进程页表项中提取的权限位。

通过以上步骤，子进程就拥有了与父进程相同内容的独立内存副本，父子进程对各自内存的修改互不影响。

2.Copy on Write 机制设计
2.1 概要设计
Copy on Write（写时复制，简称COW）是一种延迟复制的优化策略。其核心思想是：在 fork 创建子进程时，不立即复制父进程的物理内存页面，而是让父子进程共享相同的物理页面，并将这些页面标记为只读。只有当父进程或子进程尝试写入某个共享页面时，才会触发页面异常，此时再为写入方分配新的物理页面并复制内容。

这种机制的优势在于：很多情况下子进程创建后会立即调用 exec 加载新程序，此时之前复制的内存内容会被完全丢弃；或者父子进程可能只读取共享数据而不修改。COW机制避免了这些不必要的内存复制，显著提高了 fork 的效率并节省了物理内存。

2.2 详细设计
2.2.1 数据结构修改
需要在 Page 结构体中增加一个引用计数字段（如果尚未存在），用于记录有多少个进程的页表项指向该物理页面。当引用计数大于1时，表示该页面被多个进程共享。现有代码中已经存在 ref 字段可以用于此目的。

此外，需要利用页表项中的保留位或现有标志位来标识COW页面。在RISC-V的Sv39页表格式中，可以使用RSW（Reserved for Software）字段中的一位作为COW标志位，例如定义 PTE_COW 表示该页面是写时复制页面。

2.2.2 fork 过程修改
在 copy_range 函数中，不再为子进程分配新的物理页面并复制内容，而是执行以下操作：

对于父进程中每一个有效且可写的页面，首先将父进程对应页表项的写权限（PTE_W）清除，并设置COW标志位（PTE_COW）。然后在子进程的页表中创建一个新的页表项，指向相同的物理页面，同样设置为只读并带有COW标志。最后增加该物理页面的引用计数。

对于原本就是只读的页面，可以直接共享而无需设置COW标志，因为双方都不会尝试写入。

修改完成后需要刷新TLB，确保页表修改生效。

2.2.3 页面异常处理修改
当进程尝试写入一个只读页面时，会触发页面异常（Store/AMO Page Fault）。在页面异常处理函数中，需要增加对COW页面的处理逻辑。

首先检查触发异常的虚拟地址对应的页表项是否设置了COW标志。如果没有设置COW标志，说明这是一次非法的写操作，应该按照原有逻辑处理（如终止进程）。

如果页表项设置了COW标志，则检查对应物理页面的引用计数。若引用计数为1，说明当前进程是该页面的唯一使用者，此时只需将页表项的写权限恢复，清除COW标志，刷新TLB即可，无需复制。

若引用计数大于1，说明还有其他进程共享该页面，此时需要执行实际的复制操作：分配一个新的物理页面，将原页面的内容复制到新页面，将当前进程的页表项修改为指向新页面并恢复写权限，清除COW标志，将原页面的引用计数减1，最后刷新TLB。

2.2.4 进程退出处理
当进程退出时，需要正确处理COW页面。在释放进程的内存资源时，对于每个页面应该减少其引用计数，只有当引用计数降为0时才真正释放物理页面。这一逻辑与现有的 page_remove_pte 函数处理方式一致，无需特别修改。

2.2.5 关键函数修改总结
需要修改的函数包括：copy_range 函数改为建立共享映射而非复制页面；do_pgfault 函数增加COW页面的处理分支；可能还需要修改 page_insert 等函数以支持COW标志的设置。

整个COW机制的实现需要保证在多处理器环境下的正确性，对页面引用计数的操作应该是原子的，对页表的修改也需要考虑同步问题。在单处理器环境下，通过关闭中断可以保证操作的原子性

3.具体代码
```
void *src_kvaddr = page2kva(page);

void *dst_kvaddr = page2kva(npage);

memcpy(dst_kvaddr, src_kvaddr, PGSIZE);

ret = page_insert(to, npage, start, perm);
```