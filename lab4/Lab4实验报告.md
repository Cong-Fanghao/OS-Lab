# Lab4 进程管理 实验报告
**小组成员：丛方昊_2310682、钱展飞_2312479、李泽昊_2312594**

## 任务管理
- 练习0：填写已有实验
本实验依赖实验2/3。请把你做的实验2/3的代码填入本实验中代码中有“LAB2”,“LAB3”的注释相应部分。

- 练习1：分配并初始化一个进程控制块（需要编码）
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

- 练习2：为新创建的内核线程分配资源（需要编码）
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：
调用alloc_proc，首先获得一块用户信息块。
为进程分配一个内核栈。
复制原进程的内存管理信息到新进程（但内核线程不必做此事）
复制原进程上下文到新进程
将新进程添加到进程列表
唤醒新进程
返回新进程号
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

- 练习3：编写proc_run 函数（需要编码）
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：
检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
禁用中断。你可以使用/kern/sync/sync.h中定义好的宏local_intr_save(x)和local_intr_restore(x)来实现关、开中断。
切换当前进程为要运行的进程。
切换页表，以便使用新进程的地址空间。/libs/riscv.h中提供了lsatp(unsigned int pgdir)函数，可实现修改SATP寄存器值的功能。
实现上下文切换。/kern/process中已经预先编写好了switch.S，其中定义了switch_to()函数。可实现两个进程的context切换。
允许中断。
请回答如下问题：
在本实验的执行过程中，创建且运行了几个内核线程？
完成代码编写后，编译并运行代码：make qemu

- 扩展练习 Challenge：
说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？
深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

## 分配并初始化一个进程控制块
设计实现过程：
在 alloc_proc 函数的设计与实现中，主要目标是为一个新的 proc_struct 结构体分配内存并对其所有成员变量进行安全的初始化，以防止后续使用未定义的垃圾数据导致系统崩溃。首先使用 kmalloc 分配内存后，依据 proc_init 函数中的检查逻辑，将进程状态 state 初始化为 PROC_UNINIT，表示进程尚未完成构建；进程 ID pid 设为 -1，表明该进程尚未分配有效的标识符；内核栈 kstack、内存管理结构 mm、父进程指针 parent 以及中断帧指针 tf 均初始化为 0 或 NULL，因为这些资源将在后续的 do_fork 阶段分配。特别地，为了满足系统对干净环境的要求，使用 memset 函数将 context 结构体和 name 字符数组所在的内存区域彻底清零，确保上下文切换和进程名读取时不会受到残留数据的影响。最后，将页目录表 pgdir 指向内核启动页表 boot_pgdir_pa，这是因为在本实验阶段创建的主要是内核线程，它们共享内核的内存空间。

context 与 tf 的含义与作用：
proc_struct 中的 struct context context 和 struct trapframe *tf 都与保存进程状态有关。context 成员变量保存的是进程的内核上下文，其主要含义是记录进程在内核态停止执行时的关键寄存器状态，包括 ra、sp以及 s0 到 s11 等被调用者保存寄存器。它的作用在于支持进程调度过程中的上下文切换，当调度器调用 switch_to 函数时，会保存当前进程的上下文并恢复新进程的 context，从而使 CPU 的控制流跳转到 context.ra 指向的地址，在本实验中通过 copy_thread 设为 forkret 函数，并将栈切换到新进程的内核栈。而 tf 成员变量是指向进程内核栈顶部的中断帧指针，其含义是保存进程在发生中断、异常或系统调用瞬间的完整执行现场，包括程序计数器 epc、状态寄存器 status 和所有通用寄存器。它的作用在于控制进程具体的执行入口和参数传递，当进程通过 context 切换恢复运行并进入 forkret 函数后，系统会进一步调用 forkrets 将 tf 中保存的数据恢复到 CPU 寄存器中，对于新创建的内核线程，这会使 CPU 跳转到 tf->epc 所指向的 kernel_thread_entry 入口，并传递函数参数，从而真正开始执行线程定义的业务逻辑。简单来说，context 负责将 CPU 切换回进程所在的内核环境，而 tf 负责从内核环境“返回”到进程具体要执行的代码位置。
