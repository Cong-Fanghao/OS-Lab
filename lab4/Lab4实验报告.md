# Lab4 进程管理 实验报告
**小组成员：丛方昊_2310682、钱展飞_2312479、李泽昊_2312594**

## 任务管理
- 练习0：填写已有实验
本实验依赖实验2/3。请把你做的实验2/3的代码填入本实验中代码中有“LAB2”,“LAB3”的注释相应部分。

- 练习1：分配并初始化一个进程控制块（需要编码）
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

- 练习2：为新创建的内核线程分配资源（需要编码）
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：
- 调用alloc_proc，首先获得一块用户信息块。
- 为进程分配一个内核栈。
- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
- 复制原进程上下文到新进程
- 将新进程添加到进程列表
- 唤醒新进程
- 返回新进程号
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

- 练习3：编写proc_run 函数（需要编码）
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：
- 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
- 禁用中断。你可以使用/kern/sync/sync.h中定义好的宏local_intr_save(x)和local_intr_restore(x)来实现关、开中断。
- 切换当前进程为要运行的进程。
- 切换页表，以便使用新进程的地址空间。/libs/riscv.h中提供了lsatp(unsigned int pgdir)函数，可实现修改SATP寄存器值的功能。
- 实现上下文切换。/kern/process中已经预先编写好了switch.S，其中定义了switch_to()函数。可实现两个进程的context切换。
- 允许中断。
请回答如下问题：
在本实验的执行过程中，创建且运行了几个内核线程？
完成代码编写后，编译并运行代码：make qemu

- 扩展练习 Challenge：
说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？
深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

## 分配并初始化一个进程控制块
设计实现过程：
在 alloc_proc 函数的设计与实现中，主要目标是为一个新的 proc_struct 结构体分配内存并对其所有成员变量进行安全的初始化，以防止后续使用未定义的垃圾数据导致系统崩溃。首先使用 kmalloc 分配内存后，依据 proc_init 函数中的检查逻辑，将进程状态 state 初始化为 PROC_UNINIT，表示进程尚未完成构建；进程 ID pid 设为 -1，表明该进程尚未分配有效的标识符；内核栈 kstack、内存管理结构 mm、父进程指针 parent 以及中断帧指针 tf 均初始化为 0 或 NULL，因为这些资源将在后续的 do_fork 阶段分配。特别地，为了满足系统对干净环境的要求，使用 memset 函数将 context 结构体和 name 字符数组所在的内存区域彻底清零，确保上下文切换和进程名读取时不会受到残留数据的影响。最后，将页目录表 pgdir 指向内核启动页表 boot_pgdir_pa，这是因为在本实验阶段创建的主要是内核线程，它们共享内核的内存空间。

context 与 tf 的含义与作用：
proc_struct 中的 struct context context 和 struct trapframe *tf 都与保存进程状态有关。context 成员变量保存的是进程的内核上下文，其主要含义是记录进程在内核态停止执行时的关键寄存器状态，包括 ra、sp以及 s0 到 s11 等被调用者保存寄存器。它的作用在于支持进程调度过程中的上下文切换，当调度器调用 switch_to 函数时，会保存当前进程的上下文并恢复新进程的 context，从而使 CPU 的控制流跳转到 context.ra 指向的地址，在本实验中通过 copy_thread 设为 forkret 函数，并将栈切换到新进程的内核栈。而 tf 成员变量是指向进程内核栈顶部的中断帧指针，其含义是保存进程在发生中断、异常或系统调用瞬间的完整执行现场，包括程序计数器 epc、状态寄存器 status 和所有通用寄存器。它的作用在于控制进程具体的执行入口和参数传递，当进程通过 context 切换恢复运行并进入 forkret 函数后，系统会进一步调用 forkrets 将 tf 中保存的数据恢复到 CPU 寄存器中，对于新创建的内核线程，这会使 CPU 跳转到 tf->epc 所指向的 kernel_thread_entry 入口，并传递函数参数，从而真正开始执行线程定义的业务逻辑。简单来说，context 负责将 CPU 切换回进程所在的内核环境，而 tf 负责从内核环境“返回”到进程具体要执行的代码位置。

## 为新创建的内核线程分配资源
具体实现代码如下
```
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    if ((proc = alloc_proc()) == NULL)
        goto fork_out;

    if (setup_kstack(proc) != 0)
        goto bad_fork_cleanup_proc;

    if (copy_mm(clone_flags, proc) != 0)
        goto bad_fork_cleanup_kstack;

    copy_thread(proc, stack, tf);

    proc->pid = get_pid();
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process++;

    wakeup_proc(proc);
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```
### 分析
根据实验指导书的步骤，可以总结 do/_fork 的执行流程如下：
首先，通过 alloc_proc() 为新进程创建一个空的 proc_struct，用于保存进程的基本信息。如果分配成功，则继续通过 setup_kstack() 为该进程构建内核栈。随后，将新进程的父进程指向当前运行的进程，并调用 copy_mm() 根据 clone_flags 决定是否复制或共享内存管理结构。
接着，copy_thread() 用于为新建进程设置中断帧（trapframe）和运行上下文，使其能够在被调度后正常运行。完成这些设置后，通过 get_pid() 获取一个新的 PID 并赋给进程。然后将该新进程插入到哈希表和系统的进程链表中，使调度器能够感知它的存在。最后，把进程状态置为 PROC_RUNNABLE，并将其 PID 作为 do/_fork() 的返回值。

### 问题回答
根据代码中的实现，ucore 确实会给每个新 fork 的线程分配一个唯一的进程 ID（PID），这是由 get_pid() 函数保证的。具体分析如下：
- 1.初始化变量：系统首先保证 MAX_PID 的取值范围大于最大进程数量MAX_PROCESS。函数内部通过静态变量 last_pid 和 next_safe 来记录最近一次分配和未来安全可分配的 PID 上界。
- 2.PID分配逻辑：每次调用 get_pid() 时，last_pid 会自增；若超过 MAX_PID，则重新从 1 开始扫描 PID 空间。此时会重置 next_safe 为 MAX_PID，并重新进入检查流程。
- 3.检查PID的可用性：在扫描阶段，函数会遍历进程链表 proc_list，检查当前 last_pid 是否已被其他进程使用。如果冲突，则继续自增 last_pid，同时利用 next_safe 限制重复分配的范围，确保不会重复使用正在被占用的 PID。
- 4.返回唯一PID：一旦找到未被占用的PID，函数就返回该PID作为分配给新进程的唯一标识符。

## 编写proc_run函数
具体代码实现如下：
```
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        bool  flag;
        struct proc_struct* prev=current;

        local_intr_save(flag);
        current=proc;
        lastp(current->pgdir);
        switch_to(&(prev->context),&(current->context));
        local_intr_restore(flag);

    }
}
```
### 分析
#### 1.检查进程是否相同
进程切换开始阶段首先需要判断需要切换的目标进程与当前正在运行的进程是否相同。为同一进程则不需要操作，避免多余的资源消耗。

理论依据：
- 进程切换是一个开销较大的操作，包括保存和恢复进程的上下文以及管理资源等。如果目标进程与当前进程相同，跳过上下文切换可以有效提高系统的效率，减少无效的操作。

#### 2.关中断
在进行进程切换之前，使用local_intr_save(flag)禁用中断。这是为了确保进程切换的原子性，即在切换过程中不被中断打断。中断可能会改变进程的执行状态，导致切换过程中的不一致或错误。

理论依据：
- 原子性：上下文切换涉及保存和加载寄存器、堆栈、程序计数器等关键信息。如果在切换过程中发生中断，可能会导致部分上下文信息丢失或破损，最终导致系统不稳定。因此，通过禁用中断可以确保上下文切换过程中的操作是原子的，保证进程切换的一致性。
- 竞争条件：如果中断发生在上下文切换过程中，可能会导致系统的资源（如进程调度队列、CPU寄存器等）进入不一致状态。禁用中断可以防止这种情况发生，避免产生竞争条件或死锁。

#### 3.切换页表
进程都有虚拟地址空间，每个进程需要使用不同的页表来实现自己的虚拟地址到物理地址的映射。在进程切换时，操作系统需要更新lastp寄存器，从而切换到目标进程的页表基址，从而找到页表。

理论依据：
- 虚拟内存隔离：现代操作系统支持虚拟内存，每个进程都有独立的虚拟地址空间。为了保护进程的隐私和系统的安全，必须确保每个进程使用不同的页表。当一个进程切换到另一个进程时，操作系统需要更新页表基址（例如修改CR3寄存器），以确保新的进程能访问到其自己的虚拟内存空间。
- 硬件支持：CPU的内存管理单元（MMU）使用CR3等寄存器来控制虚拟地址到物理地址的映射。切换进程时，操作系统需要根据目标进程的页表更新这些寄存器，从而切换进程的虚拟内存空间。

#### 4.上下文切换
上下文切换是指将当前进程的状态（寄存器、堆栈、程序计数器等）保存到当前进程的控制块中，然后将目标进程的状态从控制块中加载到CPU中。这个过程通常涉及两个主要步骤,分别是保存当前进程的上下文和恢复目标进程的上下文。

理论依据：
- 进程状态保存与恢复：进程的状态由多个寄存器、堆栈指针、程序计数器等组成。这些状态信息必须在进程切换时保存，以便下次调度时能够恢复执行。上下文切换的核心操作是保存当前进程的执行状态，并恢复目标进程的执行状态。
- 效率和复杂性：上下文切换的效率直接影响操作系统的性能。操作系统需要在有限的时间内完成上下文的保存和恢复，以最小化上下文切换的开销。

#### 5.启动中断
完成上下文切换后，操作系统恢复了目标进程的上下文，并且允许系统重新响应中断。恢复中断是为了确保系统的正常运行，尤其是在多任务环境下，进程切换完成后，系统需要继续响应外部事件（如时钟中断、I/O中断等）。

理论依据：
- 中断响应：禁用中断只是为了保证进程切换的原子性，一旦上下文切换完成，操作系统需要恢复中断处理，以保证外部事件能够得到及时响应。恢复中断确保系统能够处理硬件中断、定时中断、系统调用等外部事件，维持系统的正常调度和操作。
- 多任务和实时性：一旦进程切换完成并恢复中断，操作系统能够重新处理外部的中断请求，这对于实时操作系统尤其重要，可以确保及时响应定时任务或硬件事件。

### 问题回答
一共创建了两个线程。第一个是idleproc，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他进程或线程；第二个是执行init_main的init线程，打印"Hello world!!"。
```
// idle proc
struct proc_struct *idleproc = NULL;
// init proc
struct proc_struct *initproc = NULL;
```


## 扩展练习challenge