# Lab4 进程管理 实验报告
**小组成员：丛方昊_2310682、钱展飞_2312479、李泽昊_2312594**

## 任务管理
- 练习0：填写已有实验
本实验依赖实验2/3。请把你做的实验2/3的代码填入本实验中代码中有“LAB2”,“LAB3”的注释相应部分。

- 练习1：分配并初始化一个进程控制块（需要编码）
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

- 练习2：为新创建的内核线程分配资源（需要编码）
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：
- 调用alloc_proc，首先获得一块用户信息块。
- 为进程分配一个内核栈。
- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
- 复制原进程上下文到新进程
- 将新进程添加到进程列表
- 唤醒新进程
- 返回新进程号
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

- 练习3：编写proc_run 函数（需要编码）
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：
- 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
- 禁用中断。你可以使用/kern/sync/sync.h中定义好的宏local_intr_save(x)和local_intr_restore(x)来实现关、开中断。
- 切换当前进程为要运行的进程。
- 切换页表，以便使用新进程的地址空间。/libs/riscv.h中提供了lsatp(unsigned int pgdir)函数，可实现修改SATP寄存器值的功能。
- 实现上下文切换。/kern/process中已经预先编写好了switch.S，其中定义了switch_to()函数。可实现两个进程的context切换。
- 允许中断。
请回答如下问题：
在本实验的执行过程中，创建且运行了几个内核线程？
完成代码编写后，编译并运行代码：make qemu

- 扩展练习 Challenge：
说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？
深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

## 分配并初始化一个进程控制块

1. 设计实现过程
alloc_proc 函数的设计核心在于创建一个“干净”且状态确定的进程控制块，这是操作系统维持进程管理稳定性的基石。在具体实现中，我们首先通过 kmalloc 分配了一块 struct proc_struct 大小的内存空间。由于 kmalloc 分配的堆内存可能残留之前的垃圾数据，直接使用会导致不可预知的内核错误，因此初始化步骤至关重要。

我们的初始化策略严格遵循了 proc_init 函数中的自检逻辑。首先，将进程生命周期状态 state 显式设定为 PROC_UNINIT，并将 pid 设为 -1，这不仅仅是赋值，更是为了标记该进程结构体尚处于“半成品”状态，避免调度器过早将其纳入调度队列。对于内核栈 kstack、内存管理指针 mm、父进程 parent 和中断帧 tf，我们统一初始化为零值，因为这些资源依赖于后续 do_fork 阶段的动态分配。

特别值得阐述的是对 context 和 name 的处理。我们没有简单地逐个成员赋值，而是使用了 memset 对这两块内存区域进行了字节级的清零。这样做有两个深层原因：其一，context 结构体中可能存在编译器自动填充的对齐字节，如果只初始化成员变量，对齐字节中的垃圾数据会导致 proc_init 中的 memcmp 检查失败；其二，确保 name 字符串以 NULL 结尾，防止打印进程名时发生内存越界。最后，将页表基址 pgdir 指向 boot_pgdir_pa，这意味着新创建的内核线程将共享内核的全局页表，直接映射物理内存，从而能够访问内核的所有代码和数据。

具体代码如下：
```
 proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;
        proc->pgdir = boot_pgdir_pa;
        proc->flags = 0;
        memset(proc->name, 0, PROC_NAME_LEN + 1);
```

2. context 与 tf 的含义与作用分析
总结来说，context 负责处理进程 A 切到进程 B的内核控制流转移，而 tf 负责处理“内核环境切入具体执行代码的现场恢复。没有 context，无法切换进程；没有 tf，进程无法知道该从哪里开始执行具体的业务逻辑。在 ucore 的进程管理机制中，struct context context 和 struct trapframe *tf 是两个至关重要但分工截然不同的状态保存结构，它们共同构成了进程切换与执行流恢复的完整链条。

struct context context：
context 位于进程控制块内部，其本质是进程在内核态之间切换的“锚点”。它专门用于保存被调用者保存寄存器。在本实验中，它的核心作用是服务于操作系统的调度器。当调度器决定暂停当前进程并运行新进程时，会调用 switch_to 函数。该函数利用汇编指令将 CPU 的寄存器快照保存到旧进程的 context 中，并将新进程的 context 加载到 CPU。此时，context.ra起到了关键的“桥梁”作用：对于新创建的进程，我们在 copy_thread 中将其手动构造为指向 forkret 函数。因此，当 switch_to 完成上下文切换的那一刻，CPU 的执行流会“欺骗性”地跳转到 forkret，仿佛进程之前是从那里暂停的一样。

*struct trapframe tf：
与 context 不同，tf 指针指向进程内核栈的高地址顶部，保存的是一个完整的硬件执行现场。它涵盖了所有通用寄存器、epc以及status，通常由硬件中断或软件异常触发时建立。在本实验的内核线程创建过程中，tf 的作用是模拟一个“假”的中断现场。我们在 kernel_thread 中预先填充了 tf，将其 epc 指向 kernel_thread_entry，并将函数参数放置在参数寄存器中。

两者的协作关系：
这两个结构体在进程启动时呈现出一种“接力”关系。

第一阶段： 调度器利用 context 将 CPU 的栈指针切换到新进程的内核栈，并将指令指针引导至 forkret 函数。
第二阶段： forkret 函数随后依据 tf 指针，调用 forkrets，即中断返回逻辑。这会把 tf 中保存的寄存器值全部恢复到 CPU 中，最终通过 sret 指令将 PC 跳转到 tf->epc。

## 为新创建的内核线程分配资源
具体实现代码如下
```
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    if ((proc = alloc_proc()) == NULL)
        goto fork_out;

    if (setup_kstack(proc) != 0)
        goto bad_fork_cleanup_proc;

    if (copy_mm(clone_flags, proc) != 0)
        goto bad_fork_cleanup_kstack;

    copy_thread(proc, stack, tf);

    proc->pid = get_pid();
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process++;

    wakeup_proc(proc);
    ret = proc->pid;
```
### 分析
根据实验指导书的步骤，可以总结 do/_fork 的执行流程如下：
首先，通过 alloc_proc() 为新进程创建一个空的 proc_struct，用于保存进程的基本信息。如果分配成功，则继续通过 setup_kstack() 为该进程构建内核栈。随后，将新进程的父进程指向当前运行的进程，并调用 copy_mm() 根据 clone_flags 决定是否复制或共享内存管理结构。
接着，copy_thread() 用于为新建进程设置中断帧（trapframe）和运行上下文，使其能够在被调度后正常运行。完成这些设置后，通过 get_pid() 获取一个新的 PID 并赋给进程。然后将该新进程插入到哈希表和系统的进程链表中，使调度器能够感知它的存在。最后，把进程状态置为 PROC_RUNNABLE，并将其 PID 作为 do/_fork() 的返回值。

### 问题回答
根据代码中的实现，ucore 确实会给每个新 fork 的线程分配一个唯一的进程 ID（PID），这是由 get_pid() 函数保证的。具体分析如下：
- 1.初始化变量：系统首先保证 MAX_PID 的取值范围大于最大进程数量MAX_PROCESS。函数内部通过静态变量 last_pid 和 next_safe 来记录最近一次分配和未来安全可分配的 PID 上界。
- 2.PID分配逻辑：每次调用 get_pid() 时，last_pid 会自增；若超过 MAX_PID，则重新从 1 开始扫描 PID 空间。此时会重置 next_safe 为 MAX_PID，并重新进入检查流程。
- 3.检查PID的可用性：在扫描阶段，函数会遍历进程链表 proc_list，检查当前 last_pid 是否已被其他进程使用。如果冲突，则继续自增 last_pid，同时利用 next_safe 限制重复分配的范围，确保不会重复使用正在被占用的 PID。
- 4.返回唯一PID：一旦找到未被占用的PID，函数就返回该PID作为分配给新进程的唯一标识符。

## 编写proc_run函数
具体代码实现如下：
```
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        bool  flag;
        struct proc_struct* prev=current;

        local_intr_save(flag);
        current=proc;
        lastp(current->pgdir);
        switch_to(&(prev->context),&(current->context));
        local_intr_restore(flag);

    }
}
```
### 分析
#### 1.检查进程是否相同
进程切换开始阶段首先需要判断需要切换的目标进程与当前正在运行的进程是否相同。为同一进程则不需要操作，避免多余的资源消耗。

理论依据：
- 进程切换是一个开销较大的操作，包括保存和恢复进程的上下文以及管理资源等。如果目标进程与当前进程相同，跳过上下文切换可以有效提高系统的效率，减少无效的操作。

#### 2.关中断
在进行进程切换之前，使用local_intr_save(flag)禁用中断。这是为了确保进程切换的原子性，即在切换过程中不被中断打断。中断可能会改变进程的执行状态，导致切换过程中的不一致或错误。

理论依据：
- 原子性：上下文切换涉及保存和加载寄存器、堆栈、程序计数器等关键信息。如果在切换过程中发生中断，可能会导致部分上下文信息丢失或破损，最终导致系统不稳定。因此，通过禁用中断可以确保上下文切换过程中的操作是原子的，保证进程切换的一致性。
- 竞争条件：如果中断发生在上下文切换过程中，可能会导致系统的资源（如进程调度队列、CPU寄存器等）进入不一致状态。禁用中断可以防止这种情况发生，避免产生竞争条件或死锁。

#### 3.切换页表
进程都有虚拟地址空间，每个进程需要使用不同的页表来实现自己的虚拟地址到物理地址的映射。在进程切换时，操作系统需要更新lastp寄存器，从而切换到目标进程的页表基址，从而找到页表。

理论依据：
- 虚拟内存隔离：现代操作系统支持虚拟内存，每个进程都有独立的虚拟地址空间。为了保护进程的隐私和系统的安全，必须确保每个进程使用不同的页表。当一个进程切换到另一个进程时，操作系统需要更新页表基址（例如修改CR3寄存器），以确保新的进程能访问到其自己的虚拟内存空间。
- 硬件支持：CPU的内存管理单元（MMU）使用CR3等寄存器来控制虚拟地址到物理地址的映射。切换进程时，操作系统需要根据目标进程的页表更新这些寄存器，从而切换进程的虚拟内存空间。

#### 4.上下文切换
上下文切换是指将当前进程的状态（寄存器、堆栈、程序计数器等）保存到当前进程的控制块中，然后将目标进程的状态从控制块中加载到CPU中。这个过程通常涉及两个主要步骤,分别是保存当前进程的上下文和恢复目标进程的上下文。

理论依据：
- 进程状态保存与恢复：进程的状态由多个寄存器、堆栈指针、程序计数器等组成。这些状态信息必须在进程切换时保存，以便下次调度时能够恢复执行。上下文切换的核心操作是保存当前进程的执行状态，并恢复目标进程的执行状态。
- 效率和复杂性：上下文切换的效率直接影响操作系统的性能。操作系统需要在有限的时间内完成上下文的保存和恢复，以最小化上下文切换的开销。

#### 5.启动中断
完成上下文切换后，操作系统恢复了目标进程的上下文，并且允许系统重新响应中断。恢复中断是为了确保系统的正常运行，尤其是在多任务环境下，进程切换完成后，系统需要继续响应外部事件（如时钟中断、I/O中断等）。

理论依据：
- 中断响应：禁用中断只是为了保证进程切换的原子性，一旦上下文切换完成，操作系统需要恢复中断处理，以保证外部事件能够得到及时响应。恢复中断确保系统能够处理硬件中断、定时中断、系统调用等外部事件，维持系统的正常调度和操作。
- 多任务和实时性：一旦进程切换完成并恢复中断，操作系统能够重新处理外部的中断请求，这对于实时操作系统尤其重要，可以确保及时响应定时任务或硬件事件。

### 问题回答
一共创建了两个线程。第一个是idleproc，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他进程或线程；第二个是执行init_main的init线程，打印"Hello world!!"。
```
// idle proc
struct proc_struct *idleproc = NULL;
// init proc
struct proc_struct *initproc = NULL;
```


## 扩展练习challenge
### 开关中断实现原理
这里local_intr_save(intr_flag);....local_intr_restore(intr_flag)是取当前SIE位状态后，调用了一个内联函数，这个内联函数可以更改sstatus寄存器的值，相关代码如下：
```
static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        intr_disable();
        return 1;
    }
    return 0;
}
```
操作RISC-V的sstatus寄存器中的SSTATUS_SIE位控制中断使能，当需要关闭中断的时候，都会保存一下现在是SIE位，然后把这个SIE置0，禁用中断，等到完成指令想要恢复中断的时候，就恢复SIE到原来的值。这样就完成了函数的开关。

### 深入理解不同分页模式的工作原理
两段代码相似的根本原因是多级页表查询时做的操作是相似的，从satp寄存器出发，通过PPN[2]找到大大页的偏移量，然后再进入大大页，根据地址信息和偏移量信息找到一个地址，从中再读取大页的偏移量，这是一个类似于递归的过程，每一级的查询逻辑是相同的。

我认为get_pte把查找和分配统一起来是好的，一方面，对于页表项的映射的创建是一个原子过程，需要涉及到关中断和开中断，对于内核来说，把这两项放在一起很安全；另一方面，虽然这里一个函数完成两个工作，但是函数给了一个create标记位，给我们提供了一个是否创建的接口，在选择不创建时，它仅仅在进行if判断时多了一个条件，这个开销和安全相比影响很小。可能对于更高级的管理方式把函数拆分一下更好，但是这里看来拆分函数是完全没有必要的。
